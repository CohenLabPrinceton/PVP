import time
import sys

from itertools import count
from vent.alarm import AlarmType, AlarmSeverity
#from vent.alarm.alarm_manager import Alarm_Manager

def get_alarm_manager():
    try:
        return Alarm_Manager()
    except:
        from vent.alarm.alarm_manager import Alarm_Manager
        return Alarm_Manager()

class Alarm:
    """
    Class used by the program to control and coordinate alarms.

    Parameterized by a :class:`Alarm_Rule` and managed by :class:`Alarm_Manager`
    """


    id_counter = count()
    """
    :class:`itertools.count`: used to generate unique IDs for each alarm
    """

    def __init__(self, alarm_type: AlarmType, severity: AlarmSeverity,
                 start_time: float = None, value=None, message=None):
        """

        Args:
            alarm_type :
            severity:
            alarm_start_time:
            alarm_end_time:
            value (int, float): optional - numerical value that generated the alarm
            message (str): optional - override default text generated by :class:`~vent.gui.alarm_manager.AlarmManager`
        """

        self.manager = get_alarm_manager()

        self.id = next(Alarm.id_counter)
        self.active = True

        assert isinstance(severity, AlarmSeverity)
        self._severity = severity

        assert isinstance(alarm_type, AlarmType)
        self._alarm_type = alarm_type


        if self.start_time is None:
            self.start_time = time.time()
        else:
            assert isinstance(start_time, float)
            self.start_time = start_time

        self.alarm_end_time = None
        self.value = value
        self.message = message

        self.manager.register_alarm(self)

    @property
    def severity(self):
        # no setter, don't want to be able to change after instantiation
        return self._severity

    @property
    def alarm_type(self):
        return self._alarm_type



    def deactivate(self):
        if self.active == False:
            return

        self.alarm_end_time = time.time()
        self.active = False
        # make sure the manager deactivates us.
        # manager checks if this has already been done so doesn't recurse
        self.manager.deactivate_alarm(self)
